<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_70398_myitsm.HLRChangeRequestStateHandler</api_name>
        <client_callable>false</client_callable>
        <description/>
        <name>HLRChangeRequestStateHandler</name>
        <script><![CDATA[var HLRChangeRequestStateHandler = Class.create();

HLRChangeRequestStateHandler.LOG_PROPERTY = "com.snc.change_management.core.log";

HLRChangeRequestStateHandler.DRAFT = "draft";
HLRChangeRequestStateHandler.ASSESS = "assess";
HLRChangeRequestStateHandler.AUTHORIZE = "authorize";
HLRChangeRequestStateHandler.SCHEDULED = "scheduled";
HLRChangeRequestStateHandler.AUTHORIZEIMPLEMENATION = "authorizeimplementation";
HLRChangeRequestStateHandler.IMPLEMENT = "implement";
HLRChangeRequestStateHandler.REVIEW = "review";
HLRChangeRequestStateHandler.CLOSED = "closed";
HLRChangeRequestStateHandler.CANCELED = "canceled";

HLRChangeRequestStateHandler.prototype = {
    /**
     * Keep a mapping of the state values and their label equivalent to make the models (ChangeRequestStateModel_normal...etc)
     * easier to work with
     */
    STATE_NAMES: {
        "-5": HLRChangeRequestStateHandler.DRAFT,
        "-4": HLRChangeRequestStateHandler.ASSESS,
        "-3": HLRChangeRequestStateHandler.AUTHORIZE,
        "-2": HLRChangeRequestStateHandler.SCHEDULED,
        "-1": HLRChangeRequestStateHandler.IMPLEMENT,
        "0": HLRChangeRequestStateHandler.REVIEW,
        "3": HLRChangeRequestStateHandler.CLOSED,
        "4": HLRChangeRequestStateHandler.CANCELED,
		"10": HLRChangeRequestStateHandler.AUTHORIZEIMPLEMENATION
    },

    NORMAL: "normal",
    EMERGENCY: "emergency",
    STANDARD: "standard",
	AUTOMATED: "automated",

    /**
     * @param changeRequestGr - GlideRecord
     */
    initialize: function(changeRequestGr) {
        this.log = new GSLog(HLRChangeRequestStateHandler.LOG_PROPERTY, this.type);
        this.log.setLog4J();

        if (!changeRequestGr)
            return;

        this._gr = changeRequestGr;
        this._resetModel();
    },

    isNext: function(state) {
		
    	var nextStates = this.getNextStates();
		
		if (!nextStates)
			return false;
    	
    	for (var i = 0; i < nextStates.length; i++)
    		if (state == nextStates[i])
    			return true;

		return false;
    },

    /**
     * Moves the change request to the next state.
     * 
     * The record's state is set but the record is not saved.
     * 
     * @returns {Boolean}
     */
    next: function() {
        var nextStates = this.getNextStates();
        if (!nextStates || nextStates.length == 0)
        	return false;
        
        this.log.debug("[next] trying to move to " + nextStates[0]);

        if (this.canMoveTo(nextStates[0])) {
            var currentState = this.getStateName(this._gr.getValue('state'));
            this._model[currentState][nextStates[0]].moving.call(this._model);
            this._gr.state = this.getStateValue(nextStates[0]);
            return true;
        }

        return false;
    },

    /**
     * Moves the change request to the given state
     * 
     * The record's state is set but the record is not saved.
     * 
     * @param toState String - name of the state to move to
     * @returns {Boolean}
     */
    moveTo: function(toState) {
        if (this.canMoveTo(toState)) {
            var currentState = this.getStateName(this._gr.getValue('state'));
            this._model[currentState][toState].moving.call(this._model);
            this._gr.state = this.getStateValue(toState);

            return true;
        }

        return false;
    },

    /**
     * Confirms that the move was allowed and executes the 'moving' function for this specific transition
     * 
     * @param toState String - name of the state to move to
     * @returns {Boolean}
     */
    moveFrom: function(fromState) {
        if (this.canMoveFrom(fromState)) {
            var currentState = this.getStateName(this._gr.getValue('state'));
            this._model[fromState][currentState].moving.call(this._model);
            return true;
        }
        return false;
    },

    /**
     * Checks if the change request at its current state is allowed to move to the given state
     * 
     * @param toState (optional) Name of the state
     * @returns {Boolean}
     */
    canMoveTo: function(toState) {
        if (!toState) {
            this.log.debug("[canMoveTo] needs a state to move to");
            return false;
        }

        var currentState = this.getStateName(this._gr.getValue('state'));
        if (!this._model[currentState]) {
            this.log.debug("[canMoveTo] " + currentState + " is not a valid state for this change");
            return false;
        }

        if (this._model[currentState][toState])
            return this._model[currentState][toState].canMove.call(this._model);

        this.log.debug("[canMoveTo] " + toState + " is not a valid state to move to");

        return false;
    },

    /**
     * Checks if the change request at its current state was allowed to move from the state provided
     * 
     * @param fromState (optional) Name of the state
     * @returns {Boolean}
     */
    canMoveFrom: function(fromState) {
        if (!fromState) {
            this.log.debug("[canMoveFrom] needs the previous state");
            return false;
        }

        var currentState = this.getStateName(this._gr.getValue('state'));
        if (!this._model[currentState]) {
            this.log.debug("[canMoveFrom] " + currentState + " is not a valid state for this change");
            return false;
        }

        if (!this._model[fromState]) {
            this.log.debug("[canMoveFrom] " + fromState + " is not a valid state for this change to have moved from");
            return false;
        }

        if (this._model[fromState][currentState])
            return this._model[fromState][currentState].canMove.call(this._model);

        this.log.debug("[canMoveFrom] " + currentState + " is not a valid state to move from " + fromState);

        return false;
    },

    /**
     * Returns the array of next states this change to may move to.
     * 
     * @returns String array state name
     */
    getNextStates: function() {
        var currentState = this.getStateName(this._gr.getValue('state'));
        if (!currentState)
            return null;

        var stateObj = this._model[currentState];

        if (!stateObj) {
            this.log.debug("[getNextStates] " + currentState + " is not a valid state for this change");
            return null;
        }

        if (!stateObj.nextState || stateObj.nextState.length === 0) {
            this.log.debug("[getNextStates] there is no 'next' state to move to from '" + currentState + "'");
            return null;
        }

        return stateObj.nextState;
    },

    /**
     * Dissociate approvals from a particular workflow activity to preserve the history.
     */
    disassociateApprovalsFromWorkflow: function() {
        if (!this._gr)
            return;

        var existingApprovalsGr = new GlideMultipleUpdate("sysapproval_approver");
        existingApprovalsGr.addQuery("sysapproval", this._gr.getUniqueValue());
        existingApprovalsGr.addQuery("state", "!=", "cancelled");
        existingApprovalsGr.setValue("wf_activity", "");
        existingApprovalsGr.execute();

        existingApprovalsGr = new GlideMultipleUpdate("sysapproval_group");
        existingApprovalsGr.addQuery("parent", this._gr.getUniqueValue());
        existingApprovalsGr.addQuery("approval", "!=", "cancelled");
        existingApprovalsGr.setValue("wf_activity", "");
        existingApprovalsGr.execute();
    },

    /**
     * Uses the current change request's type to determine and set the state model class
     */
    _resetModel: function() {
        this._model = null;
        switch (this._gr.getValue('type') + "") {
            case this.NORMAL:
                this._model = new ChangeRequestStateModel_normal(this._gr);
                break;
            case this.EMERGENCY:
                this._model = new ChangeRequestStateModel_emergency(this._gr);
                break;
            case this.STANDARD:
                this._model = new ChangeRequestStateModel_standard(this._gr);
                break;
			case this.AUTOMATED:
                this._model = new ChangeRequestStateModel_automated(this._gr);
                break;
        }
    },

    getStateName: function(value) {
        return this.STATE_NAMES[value + ""];
    },

    getStateValue: function(stateName) {
        for ( var prop in this.STATE_NAMES) {
            if (this.STATE_NAMES[prop] == stateName)
                return prop;
        }
    },

    isOnHold: function() {
        return this._model.isOnHold.call(this._model);
    },

    type: "HLRChangeRequestStateHandler"
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dejonget</sys_created_by>
        <sys_created_on>2017-06-15 12:15:12</sys_created_on>
        <sys_id>3c63b07a4fd77a00a9f9011f0310c792</sys_id>
        <sys_mod_count>9</sys_mod_count>
        <sys_name>HLRChangeRequestStateHandler</sys_name>
        <sys_package display_value="Global" source="global">global</sys_package>
        <sys_policy/>
        <sys_scope display_value="myitsm">b8cf8934dba20300e9d1de90cf961983</sys_scope>
        <sys_update_name>sys_script_include_3c63b07a4fd77a00a9f9011f0310c792</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2017-11-17 22:41:34</sys_updated_on>
    </sys_script_include>
</record_update>
